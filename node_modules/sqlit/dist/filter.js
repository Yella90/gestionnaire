"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.plainify = exports.splitKey = exports.NONE = exports.SOME = exports.NULL = exports.LIKE = exports.IN = exports.NE = exports.GT = exports.GE = exports.LE = exports.LT = exports.NOT = exports.OR = exports.AND = exports.encodeFilter = exports.QueryBuilder = exports.Context = void 0;
const database_1 = require("./database");
const record_1 = require("./record");
const sqlex_1 = require("sqlex");
const misc_1 = require("./misc");
class Context {
    constructor() {
        this.aliasMap = {};
        this.counter = 0;
    }
    getAlias(builder) {
        const model = builder.model;
        const field = builder.field;
        const names = [];
        while (builder.parent) {
            names.unshift(builder.field.name);
            builder = builder.parent;
        }
        const alias = 't' + this.counter++;
        if (field instanceof sqlex_1.ForeignKeyField) {
            this.aliasMap[names.join('.')] = { name: alias, model: model };
        }
        return alias;
    }
}
exports.Context = Context;
class QueryBuilder {
    // (model, dialect), or (parent, field)
    constructor(model, dialect) {
        this.fieldMap = {};
        if (model instanceof sqlex_1.Model) {
            this.model = model;
            this.dialect = dialect;
            this.context = new Context();
        }
        else {
            this.parent = model;
            this.field = dialect;
            this.dialect = this.parent.dialect;
            this.context = this.parent.context;
            if (dialect instanceof sqlex_1.ForeignKeyField) {
                this.model = dialect.referencedField.model;
            }
            else if (dialect instanceof sqlex_1.RelatedField) {
                this.model = dialect.referencingField.model;
            }
            this.alias = this.context.getAlias(this);
        }
    }
    getFroms() {
        let builder = this;
        while (builder && builder.field instanceof sqlex_1.ForeignKeyField) {
            builder = builder.parent;
        }
        return builder.froms;
    }
    where(args) {
        if (!args)
            return '';
        args = plainify(args);
        if (Array.isArray(args)) {
            return this.or(args);
        }
        else {
            return this.and(args);
        }
    }
    or(args) {
        const exprs = args.map(arg => this.and(arg));
        return exprs.length === 0
            ? ''
            : exprs.length === 1
                ? exprs[0]
                : exprs.map(x => `(${x})`).join(' or ');
    }
    and(args) {
        const exprs = [];
        for (const key in args) {
            const [name, operator] = splitKey(key);
            const field = this.model.field(name);
            const value = args[key];
            if (field instanceof sqlex_1.ForeignKeyField) {
                const query = value;
                if (query === null || typeof query !== 'object') {
                    exprs.push(this.expr(field, '=', value));
                }
                else if (Array.isArray(query)) {
                    const values = [];
                    const filter = [];
                    for (const arg of query) {
                        if (arg === null || typeof arg !== 'object') {
                            values.push(arg);
                        }
                        else {
                            filter.push(arg);
                        }
                    }
                    let expr = values.length > 0 ? this.expr(field, 'in', values) : 'false';
                    if (filter.length > 0) {
                        if (expr.length > 0)
                            expr += ' or ';
                        expr += this._join(field, filter);
                    }
                    if (expr.length > 0) {
                        exprs.push(`${expr}`);
                    }
                }
                else {
                    const keys = Object.keys(query);
                    if (keys.length === 1) {
                        const [name, operator] = splitKey(keys[0]);
                        if (name === field.referencedField.name) {
                            const value = query[keys[0]];
                            if (sqlex_1.isValue(value)) {
                                exprs.push(this.expr(field, operator, value));
                                continue;
                            }
                        }
                        const relatedField = field.referencedField.model.field(name);
                        if (relatedField instanceof sqlex_1.RelatedField) {
                            const referencingField = relatedField.referencingField;
                            const builder = new QueryBuilder(referencingField.model, this.dialect);
                            let filter = query[keys[0]];
                            if (relatedField.throughField && relatedField.name === keys[0]) {
                                filter = {
                                    [relatedField.throughField.name]: filter
                                };
                            }
                            const rhs = builder.select(referencingField, filter);
                            const lhs = this.alias
                                ? `${this.escapeId(this.alias)}.${this.escapeId(field)}`
                                : this.escapeId(field);
                            exprs.push(`${lhs} in (${rhs})`);
                            continue;
                        }
                    }
                    const expr = this._join(field, query);
                    if (expr.length > 0) {
                        exprs.push(`${expr}`);
                    }
                }
            }
            else if (field instanceof sqlex_1.SimpleField) {
                exprs.push(this.expr(field, operator, value));
            }
            else if (field instanceof sqlex_1.RelatedField) {
                const filter = value === '*' ? {} : value;
                exprs.push(this.exists(field, operator, filter));
            }
            else if (key === exports.AND) {
                // { and: [{name_like: "%Apple%"}, {price_lt: 6}] }
                exprs.push(value.map(c => this.and(c)).join(' and '));
            }
            else if (key === exports.OR) {
                /*
                 { or: [
                        { name_like: "%Apple%" },
                        { productCategories_some:
                          { category: { name: 'Banana' } }
                        }
                      ]
                 }
                 */
                exprs.push('(' + value.map(c => this.and(c)).join(' or ') + ')');
            }
            else if (key === exports.NOT) {
                /*
                 { not: [
                        { name_like: "%Apple%" },
                        { productCategories_some:
                          { category: { name: 'Banana' } }
                        }
                      ]
                 }
                 */
                const filters = misc_1.toArray(value);
                exprs.push('not (' + filters.map(c => this.and(c)).join(' or ') + ')');
            }
            else if (name !== '*') {
                throw Error(`Bad field: ${this.model.name}.${name}`);
            }
        }
        return exprs.length === 0
            ? ''
            : exprs.length === 1
                ? exprs[0]
                : exprs.map(x => `(${x})`).join(' and ');
    }
    expr(field, operator, value) {
        const lhs = this.encodeField(field.column.name);
        if (Array.isArray(value)) {
            if (!operator || operator === 'in') {
                const values = value
                    .filter(value => value !== null)
                    .map(value => this.escape(field, value));
                if (values.length < value.length) {
                    return values.length === 0
                        ? `${lhs} is null`
                        : `(${lhs} is null or ${lhs} in (${values.join(', ')}))`;
                }
                else {
                    if (values.length === 0)
                        return 'false';
                    return `${lhs} in (${values.join(', ')})`;
                }
            }
            else {
                throw Error(`Bad value: ${JSON.stringify(value)}`);
            }
        }
        operator = operator || '=';
        if (operator === '=' && value === null) {
            return `${lhs} is null`;
        }
        if (operator === 'null') {
            return value ? `${lhs} is null` : `${lhs} is not null`;
        }
        return `${lhs} ${operator} ${this.escape(field, value)}`;
    }
    _extendFilter(filter, orderBy) {
        for (const entry of misc_1.toArray(orderBy)) {
            const fields = entry.replace(/^-/, '').split('.');
            let result = filter;
            let model = this.model;
            for (let i = 0; i < fields.length - 1; i++) {
                const name = fields[i];
                const field = model.field(name);
                if (!(field instanceof sqlex_1.ForeignKeyField)) {
                    throw Error(`Not a foreign key: ${entry}`);
                }
                if (i < fields.length - 2 ||
                    (i === fields.length - 2 &&
                        fields[i + 1] !== field.referencedField.model.primaryKey.name())) {
                    if (!result[name]) {
                        result[name] = {};
                    }
                    result = result[name];
                    model = field.referencedField.model;
                }
            }
        }
        return filter;
    }
    _pushField(fields, path) {
        const aliasMap = this.context.aliasMap;
        let alias, field;
        const match = /^(.+)\.([^\.]+)/.exec(path);
        if (match) {
            const entry = aliasMap[match[1]];
            if (entry) {
                alias = entry.name;
                field = entry.model.field(match[2]);
            }
            else {
                alias = this.alias || this.model.table.name;
                field = this.model.field(path.split('.')[0]);
            }
        }
        else {
            alias = this.alias || this.model.table.name;
            field = this.model.field(path);
        }
        if (field instanceof sqlex_1.SimpleField) {
            const column = `${this.escapeId(alias)}.${this.escapeId(field)}`;
            if (match) {
                const name = this.escapeId(path.replace(/\./g, '__'));
                fields.push(`${column} as ${name}`);
            }
            else {
                fields.push(`${column}`);
            }
            return column;
        }
        throw new Error(`Invalid field: ${path}`);
    }
    _select(name, filter = {}, orderBy) {
        this.froms = [`${this.escapeId(this.model)} ${this.alias || ''}`];
        if (!(name instanceof sqlex_1.Field || typeof name === 'string')) {
            // { code: 'ID', user: { firstName: 'name' } }
            extendFilter(this.model, filter, name);
        }
        if (orderBy) {
            // orderBy: ['-user.email']
            filter = this._extendFilter(filter, orderBy);
        }
        const where = this.where(filter).trim();
        let fields = [];
        if (name instanceof sqlex_1.Field || typeof name === 'string') {
            fields.push(this.encodeField(name));
        }
        else if (Array.isArray(name)) {
            name.forEach(name => fields.push(this.encodeField(this.model.field(name))));
        }
        else {
            const names = getFields(this.model, name, this.fieldMap);
            for (const key of names) {
                this._pushField(fields, key);
            }
        }
        if (orderBy) {
            orderBy = misc_1.toArray(orderBy).map((order) => {
                const [path, direction] = order[0] === '-' ? [order.substr(1), 'DESC'] : [order, 'ASC'];
                const column = this._pushField(fields, path);
                return `${column} ${direction}`;
            });
        }
        return {
            fields: fields.join(', '),
            tables: this.froms.join(' left join '),
            where,
            orderBy: orderBy ? orderBy.join(', ') : null
        };
    }
    select(name, filter, orderBy, filterThunk) {
        const query = this._select(name, filter, orderBy);
        let sql = `select ${query.fields} from ${query.tables}`;
        if (query.where) {
            sql += ` where ${query.where}`;
        }
        if (filterThunk) {
            const extra = filterThunk(this);
            if (extra) {
                if (!query.where) {
                    sql += ' where ';
                }
                else {
                    sql += ' and ';
                }
                sql += `(${extra})`;
            }
        }
        if (query.orderBy) {
            sql += ` order by ${query.orderBy}`;
        }
        return sql;
    }
    column() {
        return this.encodeField(this.model.keyField().column.name);
    }
    encodeField(name) {
        if (name instanceof sqlex_1.SimpleField) {
            name = name.column.name;
        }
        if (/count\(\*\)/i.test(name)) {
            return name;
        }
        else if (name !== '*') {
            name = this.escapeId(name);
        }
        const alias = this.alias || this.escapeId(this.model.table.name);
        return `${alias}.${name}`;
    }
    _join(field, args) {
        if (!this.getFroms())
            return this._in(field, args);
        const builder = new QueryBuilder(this, field);
        const model = field.referencedField.model;
        const keys = Object.keys(args);
        if (keys.length === 1 && keys[0] === model.keyField().name) {
            if (sqlex_1.isValue(args[keys[0]])) {
                return this.expr(field, null, args[keys[0]]);
            }
        }
        const name = `${this.escapeId(model.table.name)} ${builder.alias}`;
        const lhs = this.encodeField(field);
        const rhs = builder.encodeField(model.keyField());
        this.getFroms().push(`${name} on ${lhs}=${rhs}`);
        return builder.where(args);
    }
    _in(field, args) {
        const builder = new QueryBuilder(this, field);
        const model = field.referencedField.model;
        const keys = Object.keys(args);
        if (keys.length === 1 && keys[0] === model.keyField().name) {
            return this.expr(field, null, args[keys[0]]);
        }
        const lhs = this.encodeField(field.column.name);
        const rhs = builder.select(model.keyField().column.name, args);
        return `${lhs} in (${rhs})`;
    }
    exists(field, operator, args) {
        const builder = new QueryBuilder(this, field);
        const where = field.throughField
            ? builder._in(field.throughField, args)
            : builder.where(args);
        const scope = builder.select('*') +
            ' where ' +
            builder.encodeField(field.referencingField.column.name) +
            '=' +
            this.encodeField(this.model.keyField().name);
        const exists = operator === 'none' ? 'not exists' : 'exists';
        return where.length > 0
            ? `${exists} (${scope} and ${where})`
            : `${exists} (${scope})`;
    }
    escape(field, value) {
        if (/^bool/i.test(field.column.type)) {
            return value ? 'true' : 'false';
        }
        if (/int|float|double|number/i.test(field.column.type)) {
            if (typeof value === 'number') {
                return value + '';
            }
        }
        return this.dialect.escape(database_1.toRow(value, field) + '');
    }
    escapeId(name) {
        if (name instanceof sqlex_1.SimpleField) {
            name = name.column.name;
        }
        else if (name instanceof sqlex_1.Model) {
            name = name.table.name;
        }
        return this.dialect.escapeId(name);
    }
}
exports.QueryBuilder = QueryBuilder;
function encodeFilter(args, model, escape) {
    const builder = new QueryBuilder(model, escape);
    return builder.where(args);
}
exports.encodeFilter = encodeFilter;
exports.AND = 'and';
exports.OR = 'or';
exports.NOT = 'not';
exports.LT = 'lt';
exports.LE = 'le';
exports.GE = 'ge';
exports.GT = 'gt';
exports.NE = 'ne';
exports.IN = 'in';
exports.LIKE = 'like';
exports.NULL = 'null';
exports.SOME = 'some';
exports.NONE = 'none';
const OPERATOR_MAP = {
    [exports.LT]: '<',
    [exports.LE]: '<=',
    [exports.GE]: '>=',
    [exports.GT]: '>',
    [exports.NE]: '<>',
    [exports.IN]: 'in',
    [exports.LIKE]: 'like'
};
function splitKey(arg) {
    const match = /^(.+?)_([^_]+)$/.exec(arg);
    if (match) {
        const op = match[2] in OPERATOR_MAP ? OPERATOR_MAP[match[2]] : match[2];
        return [match[1], op];
    }
    return [arg];
}
exports.splitKey = splitKey;
function plainify(value) {
    if (Array.isArray(value)) {
        return value
            .filter(entry => entry !== undefined)
            .map(entry => plainify(entry));
    }
    else if (sqlex_1.isValue(value)) {
        return value;
    }
    else if (value instanceof record_1.Record) {
        const model = value.__table.model;
        if (value.__primaryKey()) {
            return { [model.keyField().name]: value.__primaryKey() };
        }
        else {
            return database_1.getUniqueFields(model, value.__data);
        }
    }
    else {
        const result = {};
        for (const key in value) {
            result[key] = plainify(value[key]);
        }
        return result;
    }
}
exports.plainify = plainify;
function pkOnly(doc, model) {
    if (doc && !sqlex_1.isValue(doc)) {
        const keys = Object.keys(doc);
        return keys.length === 1 && keys[0] === model.keyField().name;
    }
    return false;
}
// Extends the filter to include foreign key fields
function extendFilter(model, filter, fields) {
    for (const name in fields) {
        const value = fields[name] === '*' ? {} : fields[name];
        if (value && typeof value === 'object') {
            const field = model.field(name);
            if (field instanceof sqlex_1.ForeignKeyField) {
                if (!filter[name]) {
                    filter[name] = {};
                }
                if (fields[name] === '*' ||
                    !pkOnly(value, field.referencedField.model)) {
                    filter[name]['*'] = true;
                }
                extendFilter(field.referencedField.model, filter[name], value);
            }
        }
    }
}
function getFields(model, input, fieldMap, prefix) {
    let result = [];
    const getKey = (name) => (prefix ? `${prefix}.${name}` : name);
    // By default, all fields in a model are included in the query result
    for (const field of model.fields) {
        if (field instanceof sqlex_1.SimpleField) {
            result.push(getKey(field.name));
        }
    }
    if (typeof input === 'string') {
        if (input === '*')
            return result;
    }
    for (const name in input) {
        const key = getKey(name);
        const value = input[name];
        if (!value) {
            const index = result.indexOf(key);
            if (index > -1) {
                result.splice(index, 1);
            }
        }
        else {
            const field = model.field(name);
            if (field instanceof sqlex_1.ForeignKeyField) {
                const model = field.referencedField.model;
                if (!database_1.shouldSelectSeparately(model, value)) {
                    const fields = getFields(model, value, fieldMap, key);
                    result = result.concat(fields);
                }
            }
            else if (typeof value === 'string') {
                fieldMap[key.replace(/\./g, '__')] = value;
            }
        }
    }
    return result;
}
//# sourceMappingURL=filter.js.map