"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapDocument = exports.recordConfigToDocument = exports.loadTable = exports.parseRelatedOption = void 0;
const sqlex_1 = require("sqlex");
function append(table, data, config, defaults) {
    const db = table.db;
    const model = table.model;
    const row = table.append();
    const defaultMap = new Map();
    const rowMap = new Map();
    for (const key in data) {
        const value = data[key];
        if (value === undefined)
            continue;
        if (key in config) {
            const setField = selector => {
                let _model = model;
                let _row = row;
                let _defaults = defaults;
                const names = selector.split('.');
                for (let i = 0; i < names.length - 1; i++) {
                    _defaults = _defaults && _defaults[names[i]];
                    const path = names.slice(0, i + 1).join('.');
                    const row = rowMap.get(path);
                    if (row) {
                        _row = row;
                    }
                    else {
                        _row = getRecordField(_row, _model.field(names[i]));
                        rowMap.set(path, _row);
                        if (_model.field(names[i]) instanceof sqlex_1.RelatedField && _defaults) {
                            defaultMap.set(_row, _defaults);
                        }
                    }
                    _model = _row.__table.model;
                }
                const field = _model.field(names[names.length - 1]);
                if (field instanceof sqlex_1.ForeignKeyField) {
                    _row[names[names.length - 1]] = value || null;
                }
                else {
                    _row[names[names.length - 1]] = value;
                }
            };
            if (Array.isArray(config[key])) {
                for (const name of config[key]) {
                    setField(name);
                }
            }
            else {
                setField(config[key]);
            }
        }
        else {
            // "*": "categoryAttributes[name,value]"
            if (!config['*']) {
                throw Error(`Unknown field: ${key}`);
            }
            const option = parseRelatedOption(config['*']);
            const field = model.field(option.name);
            if (field instanceof sqlex_1.RelatedField) {
                const table = db.table(field.referencingField.model);
                let record = table.append();
                record[field.referencingField.name] = row;
                if (option.value) {
                    record[option.key] = key;
                    record[option.value] = value;
                }
                else {
                    if (!field.throughField) {
                        record[option.key] = value;
                    }
                    else {
                        const referencedField = field.throughField.referencedField;
                        const referencedTable = db.table(referencedField.model);
                        const referencedRecord = referencedTable.append();
                        referencedRecord[option.key] = value;
                        record[field.throughField.name] = referencedRecord;
                        record = referencedRecord;
                    }
                }
                const _defaults = defaults && defaults[field.name];
                if (_defaults) {
                    setDefaults(record, _defaults);
                }
            }
            else {
                throw Error(`Invalid field: ${model.name}.${key}`);
            }
        }
    }
    if (defaults) {
        setDefaults(row, defaults);
        defaultMap.forEach((defaults, row) => {
            setDefaults(row, defaults);
        });
    }
    return row;
}
function getRecordField(row, field) {
    const db = row.__table.db;
    if (field instanceof sqlex_1.ForeignKeyField) {
        if (!row[field.name]) {
            row[field.name] = db.table(field.referencedField).append();
        }
        return row[field.name];
    }
    else if (field instanceof sqlex_1.RelatedField) {
        if (field.throughField) {
            const record = db
                .table(field.throughField.referencedField.model)
                .append();
            const bridge = db.table(field.referencingField.model).append();
            bridge[field.referencingField.name] = row;
            bridge[field.throughField.name] = record;
            return record;
        }
        else {
            const table = db.table(field.referencingField.model);
            const record = table.append();
            record[field.referencingField.name] = row;
            return record;
        }
    }
    throw Error(`Invalid field: ${field && field.fullname}`);
}
function setDefaults(row, defaults) {
    for (const name in defaults) {
        const field = row.__table.model.field(name);
        const value = defaults[name];
        if (field instanceof sqlex_1.ForeignKeyField) {
            if (row[name] === undefined) {
                if (value === null) {
                    row[name] = null;
                    continue;
                }
                row[name] = row.__table.db.table(field.referencedField.model).append();
            }
            if (typeof value === 'object' && !(value instanceof Date)) {
                setDefaults(row[name], value);
            }
            else {
                row[name].__setPrimaryKey(value);
            }
        }
        else if (field instanceof sqlex_1.SimpleField) {
            if (row[name] === undefined) {
                row[name] = value;
            }
        }
    }
}
function parseRelatedOption(spec) {
    // "categoryAttributes[name,value]"
    const [name, optional] = spec.split('[');
    if (optional) {
        const parts = optional.replace(/\]\s*$/, '').split(',');
        return {
            name,
            key: parts[0].trim(),
            value: parts[1] && parts[1].trim()
        };
    }
    return {
        name,
        key: 'name',
        value: 'value'
    };
}
exports.parseRelatedOption = parseRelatedOption;
function loadTable(table, data, config, defaults) {
    if (Array.isArray(data)) {
        for (const row of data) {
            append(table, row, config, defaults);
        }
    }
    else {
        append(table, data, config, defaults);
    }
    return table.db.flush();
}
exports.loadTable = loadTable;
function recordConfigToDocument(table, config) {
    const result = {};
    for (const name in config) {
        let selector;
        if (Array.isArray(config[name])) {
            selector = config[name][0];
        }
        else {
            selector = config[name];
        }
        let names = selector.split('.');
        let model = table.model;
        let fields = result;
        for (let i = 0; i < names.length - 1; i++) {
            const field = model.field(names[i]);
            if (field instanceof sqlex_1.ForeignKeyField) {
                model = field.referencedField.model;
            }
            else {
                const related = field;
                if (related.throughField) {
                    model = related.throughField.referencedField.model;
                }
                else {
                    model = related.referencingField.model;
                }
            }
            if (field instanceof sqlex_1.RelatedField) {
                if (!fields[field.name]) {
                    fields[field.name] = { fields: {} };
                }
                fields = fields[field.name].fields;
            }
            else {
                if (!fields[field.name]) {
                    fields[field.name] = {};
                }
                fields = fields[field.name];
            }
        }
        fields[names[names.length - 1]] = names[names.length - 1];
    }
    return result;
}
exports.recordConfigToDocument = recordConfigToDocument;
function mapDocument(doc, config) {
    const result = [];
    for (const entry of flatten(doc)) {
        const item = {};
        for (const name in config) {
            const path = Array.isArray(config[name]) ? config[name][0] : config[name];
            if (entry[path] !== undefined) {
                item[name] = entry[path];
            }
        }
        result.push(item);
    }
    return result;
}
exports.mapDocument = mapDocument;
function flatten(doc) {
    let result = [{}];
    for (const name in doc) {
        const value = doc[name];
        if (Array.isArray(value)) {
            const next = [];
            if (value.length > 0) {
                for (const val of value) {
                    const docs = flatten(val);
                    for (const doc of docs) {
                        for (const res of result) {
                            const ent = Object.assign({}, res);
                            for (const key in doc) {
                                ent[`${name}.${key}`] = doc[key];
                            }
                            next.push(ent);
                        }
                    }
                }
                result = next;
            }
            else {
                // Keep
            }
        }
        else if (value && typeof value === 'object' && !(value instanceof Date)) {
            const docs = flatten(value);
            const next = [];
            for (const doc of docs) {
                for (const res of result) {
                    const ent = Object.assign({}, res);
                    for (const key in doc) {
                        ent[`${name}.${key}`] = doc[key];
                    }
                    next.push(ent);
                }
            }
            result = next;
        }
        else {
            for (const entry of result) {
                entry[name] = value;
            }
        }
    }
    return result;
}
//# sourceMappingURL=loader.js.map