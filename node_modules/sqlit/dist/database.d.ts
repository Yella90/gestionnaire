import { ConnectionInfo } from './engine';
import { FlushOptions } from './flush';
import { Record } from './record';
import { RecordConfig } from './loader';
import { Schema, Model, Field, SimpleField, ForeignKeyField, RelatedField, Column as ColumnInfo, Document, Value } from 'sqlex';
import { Schema as SchemaConfig } from 'sqlex/dist/config';
import { Connection, ConnectionPool, Row } from './engine';
export declare type Filter = Document | Document[];
import { QueryBuilder } from './filter';
import { FieldOptions } from './select';
export declare class ClosureTable {
    table: Table;
    ancestor: ForeignKeyField;
    descendant: ForeignKeyField;
    depth?: SimpleField;
    constructor(table: Table, ancestor: ForeignKeyField, descendant: ForeignKeyField, depth?: SimpleField);
}
export declare class Database {
    name: string;
    schema: Schema;
    pool: ConnectionPool;
    tableMap: {
        [key: string]: Table;
    };
    tableList: Table[];
    constructor(connection: ConnectionPool | ConnectionInfo, schema?: Schema);
    getModels(bulk?: boolean): {
        [key: string]: any;
    };
    buildSchema(config?: SchemaConfig): Promise<Schema>;
    clone(): Database;
    private setSchema;
    table(name: string | Field | Model): Table;
    model(name: string): Model;
    append(name: string, data: {
        [key: string]: any;
    }): any;
    getDirtyCount(): number;
    flush(flushOptions?: FlushOptions): Promise<Connection>;
    end(): Promise<void>;
    clear(): void;
    json(): {};
}
export declare type OrderBy = string | string[];
export interface SelectOptions {
    where?: Filter;
    offset?: number;
    limit?: number;
    orderBy?: OrderBy;
}
export declare class Table {
    db: Database;
    name: string;
    model: Model;
    closureTable?: ClosureTable;
    recordList: Record[];
    recordMap: {
        [key: string]: {
            [key: string]: Record;
        };
    };
    constructor(db: Database, model: Model);
    column(name: string): ColumnInfo;
    getParentField(model?: Model): ForeignKeyField;
    getAncestors(row: Value | Document, filter?: Filter): Promise<Document[]>;
    getDescendants(row: Value | Document, filter?: Filter): Promise<Document[]>;
    select(fields: string | Document, options?: SelectOptions, filterThunk?: (builder: QueryBuilder) => string, connection?: Connection): Promise<Document[]>;
    _resolveRelatedFields(connection: Connection, result: Document[], fields: string | Document): Promise<Document[]>;
    get(key: Value | Filter): Promise<Document>;
    insert(data: Row): Promise<any>;
    create(data: Document): Promise<Document>;
    update(data: Document, filter: Filter): Promise<any>;
    upsert(data: Document, update?: Document): Promise<Document>;
    modify(data: Document, filter: Filter): Promise<Document>;
    private _call;
    delete(filter: Filter): Promise<any>;
    replace(data: Document): Promise<Record>;
    count(filter?: Filter, expr?: string): Promise<number>;
    private _name;
    private _where;
    private _pair;
    private _select;
    _update(connection: Connection, fields: Document, filter: Filter): Promise<any>;
    _insert(connection: Connection, data: Row): Promise<any>;
    _delete(connection: Connection, filter: Filter): Promise<any>;
    escapeName(name: SimpleField | string | number): string;
    escapeValue(field: SimpleField | string, value: Value): string;
    _get(connection: Connection, key: Value | Filter): Promise<Document>;
    _resolveParentFields(connection: Connection, input: Document, filter?: Filter): Promise<Row>;
    _create(connection: Connection, data: Document): Promise<Document>;
    private _upsert;
    private _modify;
    private _updateChildFields;
    private _updateChildField;
    _disconnectUnique(connection: Connection, field: SimpleField, id: Value): Promise<any>;
    _connectThrough(connection: Connection, related: RelatedField, value: Value, args: Document[]): Promise<any>;
    private _createThrough;
    private _upsertThrough;
    private _updateThrough;
    _deleteThrough(connection: Connection, related: RelatedField, value: Value, args: Document[]): Promise<any>;
    _disconnectThrough(connection: Connection, related: RelatedField, value: Value, args: Document[]): Promise<any>;
    claim(filter: Filter, data: Document, orderBy?: string[]): Promise<Document>;
    append(data?: {
        [key: string]: any;
    } | any[]): Record;
    clear(): void;
    getDirtyCount(): number;
    json(): {}[];
    _mapGet(record: Record): Record;
    _mapPut(record: Record): void;
    _initMap(): void;
    _selectRelated(connection: Connection, field: RelatedField, values: Value[], fields: any, selectOptions: SelectOptions): Promise<any[]>;
    xappend(data: Document | Document[], config: RecordConfig, defaults?: Document): Promise<any>;
    xselect(config: RecordConfig, options?: SelectOptions): Promise<Document[]>;
    selectTree(filter: Filter, options?: FieldOptions): Promise<Document[] | null>;
}
export declare function _toCamel(value: Value, field: SimpleField): Value;
export declare function toRow(value: Value, field: SimpleField): Value;
export declare function toDocument(row: Row, model: Model, fieldMap?: {}): Document;
export declare function isEmpty(value: Value | Record | any): any;
export declare function shouldSelectSeparately(model: Model, fields: string | Document): boolean;
export declare function getUniqueFields(model: Model, row: Document): {};
