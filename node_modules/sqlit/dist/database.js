"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUniqueFields = exports.shouldSelectSeparately = exports.isEmpty = exports.toDocument = exports.toRow = exports._toCamel = exports.Table = exports.Database = exports.ClosureTable = void 0;
const engine_1 = require("./engine");
const flush_1 = require("./flush");
const record_1 = require("./record");
const loader_1 = require("./loader");
const sqlex_1 = require("sqlex");
const engine_2 = require("./engine");
const filter_1 = require("./filter");
const misc_1 = require("./misc");
const tree_1 = require("./tree");
const select_1 = require("./select");
const serialiser_1 = require("./serialiser");
class ClosureTable {
    constructor(table, ancestor, descendant, depth) {
        this.table = table;
        this.ancestor = ancestor;
        this.descendant = descendant;
        this.depth = depth;
    }
}
exports.ClosureTable = ClosureTable;
class Database {
    constructor(connection, schema) {
        this.tableMap = {};
        this.tableList = [];
        if (connection instanceof engine_2.ConnectionPool) {
            this.pool = connection;
            this.name = this.pool.name;
        }
        else if (connection) {
            this.pool = engine_1.createConnectionPool(connection.dialect, connection.connection);
            this.name = connection.connection.database || connection.connection.name;
        }
        if (schema)
            this.setSchema(schema);
    }
    getModels(bulk = false) {
        return this.tableList.reduce((map, table) => {
            map[table.model.name] = record_1.getModel(table, bulk);
            return map;
        }, {});
    }
    buildSchema(config) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.schema)
                return Promise.resolve(this.schema);
            return new Promise(resolve => this.pool.getConnection().then(connection => engine_2.getInformationSchema(connection, this.name).then(schemaInfo => {
                const schema = new sqlex_1.Schema(schemaInfo, config);
                this.setSchema(schema);
                connection.release();
                resolve(schema);
            })));
        });
    }
    clone() {
        return new Database(this.pool, this.schema);
    }
    setSchema(schema) {
        this.schema = schema;
        for (const model of schema.models) {
            const table = new Table(this, model);
            this.tableMap[model.name] = table;
            this.tableMap[model.table.shortName] = table;
            this.tableList.push(table);
        }
        for (const model of schema.models) {
            if (model.config.closureTable) {
                const config = model.config.closureTable;
                const fields = config.fields || {};
                const table = this.table(config.name);
                if (!table) {
                    throw Error(`Table ${config.name} not found.`);
                }
                let fieldName = fields.ancestor || 'ancestor';
                const ancestor = table.model.field(fieldName);
                if (!ancestor || !(ancestor instanceof sqlex_1.ForeignKeyField)) {
                    throw Error(`Field ${fieldName} is not a foreign key`);
                }
                fieldName = fields.descendant || 'descendant';
                const descendant = table.model.field(fieldName);
                if (!descendant || !(descendant instanceof sqlex_1.ForeignKeyField)) {
                    throw Error(`Field ${fieldName} is not a foreign key`);
                }
                let depth;
                if (fields.depth) {
                    depth = table.model.field(fields.depth);
                    if (!depth) {
                        throw Error(`Field ${fields.depth} not found`);
                    }
                }
                this.table(model).closureTable = new ClosureTable(table, ancestor, descendant, depth);
            }
        }
    }
    table(name) {
        if (name instanceof sqlex_1.Field) {
            name = name.model.name;
        }
        else if (name instanceof sqlex_1.Model) {
            name = name.name;
        }
        return this.tableMap[name];
    }
    model(name) {
        return this.table(name).model;
    }
    append(name, data) {
        return this.table(name).append(data);
    }
    getDirtyCount() {
        return this.tableList.reduce((count, table) => {
            count += table.getDirtyCount();
            return count;
        }, 0);
    }
    flush(flushOptions) {
        return this.pool.getConnection().then(connection => flush_1.flushDatabase(connection, this, flushOptions).then(() => {
            connection.release();
            return connection;
        }));
    }
    end() {
        return this.pool ? this.pool.end() : Promise.resolve();
    }
    clear() {
        for (const name in this.tableMap) {
            this.tableMap[name].clear();
        }
    }
    json() {
        return this.tableList.reduce((result, table) => {
            result[table.model.name] = table.json();
            return result;
        }, {});
    }
}
exports.Database = Database;
class Table {
    constructor(db, model) {
        this.recordList = [];
        this.db = db;
        this.name = model.table.name;
        this.model = model;
        this._initMap();
    }
    column(name) {
        const field = this.model.field(name);
        return field.column;
    }
    getParentField(model) {
        return this.model.getForeignKeyOf(model || this.model);
    }
    getAncestors(row, filter) {
        const field = this.closureTable.ancestor;
        return this.db.pool.getConnection().then(connection => tree_1.treeQuery(connection, this, row, field, filter).then(result => {
            connection.release();
            return result;
        }));
    }
    getDescendants(row, filter) {
        const field = this.closureTable.descendant;
        return this.db.pool.getConnection().then(connection => tree_1.treeQuery(connection, this, row, field, filter).then(result => {
            connection.release();
            return result;
        }));
    }
    select(fields, options = {}, filterThunk, connection) {
        return __awaiter(this, void 0, void 0, function* () {
            if (connection) {
                const result = yield this._select(connection, fields, options, filterThunk);
                yield this._resolveRelatedFields(connection, result, fields);
                return result;
            }
            connection = yield this.db.pool.getConnection();
            try {
                const result = yield this._select(connection, fields, options, filterThunk);
                yield this._resolveRelatedFields(connection, result, fields);
                connection.release();
                return result;
            }
            catch (error) {
                connection.release();
                throw error;
            }
        });
    }
    _resolveRelatedFields(connection, result, fields) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof fields === 'string' || fields instanceof sqlex_1.SimpleField) {
                return Promise.resolve(result);
            }
            const pk = this.model.keyField().name;
            const values = result.map(row => this.model.valueOf(row, pk));
            for (const name in fields) {
                const field = this.model.field(name);
                const value = fields[name];
                if (field instanceof sqlex_1.RelatedField && value) {
                    let options, fields;
                    if (typeof value !== 'object') {
                        options = {};
                    }
                    else {
                        options = Object.assign({}, value);
                        // TODO: Document options.fields for related fields!
                        if (options.fields) {
                            fields = options.fields;
                            delete options.fields;
                        }
                        else {
                            fields = '*';
                        }
                    }
                    const rows = yield this._selectRelated(connection, field, values, fields, options);
                    result.forEach((entry, index) => {
                        entry[name] = rows[index];
                    });
                }
            }
            for (const name in fields) {
                const field = this.model.field(name);
                const value = fields[name];
                if (value) {
                    if (field instanceof sqlex_1.ForeignKeyField) {
                        const table = this.db.table(field.referencedField.model);
                        if (shouldSelectSeparately(table.model, value)) {
                            const values = [];
                            for (const row of result) {
                                const doc = row[field.name];
                                if (doc === null) {
                                    values.push(null);
                                }
                                else {
                                    values.push(table.model.keyValue(doc));
                                }
                            }
                            const docs = yield table.select(value, {
                                where: { [table.model.keyField().name]: values }
                            }, undefined, connection);
                            for (const row of result) {
                                const value = table.model.keyValue(row[field.name]);
                                const doc = docs.find(doc => table.model.keyValue(doc) === value);
                                if (doc) {
                                    row[field.name] = JSON.parse(JSON.stringify(doc));
                                }
                            }
                        }
                        else if (field instanceof sqlex_1.RelatedField) {
                            const rows = result
                                .map(r => r[name])
                                .reduce((result, rows) => {
                                result = result.concat(rows);
                                return result;
                            }, []);
                            const table = this.db.table(field.referencingField.model);
                            yield table._resolveRelatedFields(connection, rows, value);
                        }
                    }
                }
            }
            return result;
        });
    }
    get(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._call('_get', key);
        });
    }
    insert(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._call('_insert', data);
        });
    }
    create(data) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._call('_create', data);
        });
    }
    update(data, filter) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._call('_update', data, filter);
        });
    }
    upsert(data, update) {
        return this._call('_upsert', data, update);
    }
    modify(data, filter) {
        return this._call('_modify', data, filter);
    }
    _call(method, data, filter) {
        return __awaiter(this, void 0, void 0, function* () {
            const connection = yield this.db.pool.getConnection();
            try {
                const result = yield this[method](connection, data, filter);
                connection.release();
                return result;
            }
            catch (error) {
                connection.release();
                throw error;
            }
        });
    }
    delete(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.closureTable)
                return this._call('_delete', filter);
            const connection = yield this.db.pool.getConnection();
            try {
                return connection.transaction(() => this._delete(connection, filter).then(result => {
                    connection.release();
                    return result;
                }));
            }
            catch (error) {
                connection.release();
                throw error;
            }
        });
    }
    replace(data) {
        return this.db.pool.getConnection().then(connection => connection.transaction(() => flush_1.replaceRecord(connection, this, data).then(record => {
            connection.release();
            return record;
        })));
    }
    count(filter, expr) {
        let sql;
        if (expr) {
            sql = `select count(${expr}) as result from ${this._name()}`;
        }
        else {
            sql = `select count(1) as result from ${this._name()}`;
        }
        if (filter) {
            sql += ` where ${this._where(filter)}`;
        }
        return this.db.pool.getConnection().then(connection => connection.query(sql).then(rows => {
            connection.release();
            return parseInt(rows[0].result);
        }));
    }
    _name() {
        return this.db.pool.escapeId(this.model.table.name);
    }
    _where(filter) {
        return filter_1.encodeFilter(filter, this.model, this.db.pool);
    }
    _pair(name, value) {
        if (typeof name === 'string') {
            name = this.model.field(name);
        }
        return this.escapeName(name) + '=' + this.escapeValue(name, value);
    }
    _select(connection, fields, options = {}, filterThunk) {
        const builder = new filter_1.QueryBuilder(this.model, this.db.pool);
        let sql = builder.select(fields, options.where, options.orderBy, filterThunk);
        if (options.limit !== undefined) {
            sql += ` limit ${parseInt(options.limit + '')}`;
        }
        if (options.offset !== undefined) {
            sql += ` offset ${parseInt(options.offset + '')}`;
        }
        return connection.query(sql).then(rows => {
            return rows.map(row => {
                const doc = toDocument(row, this.model, builder.fieldMap);
                if (filterThunk) {
                    for (const key in row) {
                        if (key.indexOf('__') !== -1) {
                            doc[key] = row[key];
                        }
                    }
                }
                return doc;
            });
        });
    }
    _update(connection, fields, filter) {
        const data = Object.assign({}, fields);
        for (const name in filter) {
            if (name in data) {
                const lhs = this.model.valueOf(data, name);
                const rhs = this.model.valueOf(filter, name);
                if (lhs === null) {
                    if (rhs === null) {
                        delete data[name];
                    }
                    continue;
                }
                if (rhs === null)
                    continue;
                if (lhs.toString() === rhs.toString()) {
                    delete data[name];
                }
            }
        }
        if (Object.keys(data).length === 0) {
            return Promise.resolve(0);
        }
        let sql = `update ${this._name()} set `;
        let cnt = 0;
        const keys = Object.keys(data);
        for (let i = 0; i < keys.length; i++) {
            const field = this.model.field(keys[i]);
            if (field instanceof sqlex_1.SimpleField) {
                if (i > 0) {
                    sql += ',';
                }
                sql += this._pair(field, data[keys[i]]);
                cnt++;
            }
        }
        if (cnt === 0) {
            return Promise.resolve();
        }
        if (filter) {
            if (typeof filter === 'string') {
                sql += ` where ${filter}`;
            }
            else {
                sql += ` where ${this._where(filter)}`;
            }
        }
        return connection.query(sql);
    }
    _insert(connection, data) {
        const keys = Object.keys(data);
        if (keys.length === 0)
            throw Error(`${this.model.name}: No data`);
        const name = keys.map(key => this.escapeName(key)).join(', ');
        const value = keys.map(key => this.escapeValue(key, data[key])).join(', ');
        const sql = `insert into ${this._name()} (${name}) values (${value})`;
        return connection
            .query(sql, this.model.keyField().column.name)
            .then(insertId => (typeof insertId === 'number' ? insertId : 0));
    }
    _delete(connection, filter) {
        const scope = filter ? `${this._where(filter)}` : '';
        const __delete = () => {
            let sql = `delete from ${this._name()}`;
            if (scope) {
                sql += ` where ${scope}`;
            }
            return connection.query(sql);
        };
        if (this.closureTable) {
            return tree_1.deleteSubtree(connection, this, scope).then(() => __delete());
        }
        else {
            return __delete();
        }
    }
    escapeName(name) {
        if (name instanceof sqlex_1.SimpleField) {
            name = name.column.name;
        }
        else {
            if (typeof name === 'number') {
                return name + '';
            }
            if (name === '*')
                return name;
            name = this.model.field(name).column.name;
        }
        return this.db.pool.escapeId(name);
    }
    escapeValue(field, value) {
        if (typeof value === 'boolean') {
            return value ? 'true' : 'false';
        }
        if (value === null || value === undefined) {
            return 'null';
        }
        if (typeof field === 'string') {
            field = this.model.field(field);
        }
        return this.db.pool.escape(toRow(value, field) + '');
    }
    _get(connection, key) {
        if (key === undefined)
            throw Error(`Bad filter`);
        if (key === null || typeof key !== 'object') {
            key = {
                [this.model.keyField().name]: key
            };
        }
        else if (!this.model.checkUniqueKey(key)) {
            const msg = `Bad selector: ${JSON.stringify(key)}`;
            return Promise.reject(Error(msg));
        }
        return this._select(connection, '*', { where: key }).then(rows => rows[0]);
    }
    // GraphQL mutations
    _resolveParentFields(connection, input, filter) {
        const result = {};
        const promises = [];
        const self = this;
        function _createPromise(field, data) {
            const table = self.db.table(field.referencedField.model);
            const method = Object.keys(data)[0];
            let promise;
            switch (method) {
                case 'connect':
                    promise = table._get(connection, data[method]);
                    break;
                case 'create':
                    promise = table._create(connection, data[method]);
                    break;
                case 'update':
                    {
                        const where = { [field.relatedField.name]: filter };
                        promise = table._modify(connection, data[method], where);
                    }
                    break;
                default:
                    throw Error(`Unsuported method '${method}'`);
            }
            if (method !== 'update') {
                promise.then(row => {
                    result[field.name] = row
                        ? row[field.referencedField.model.keyField().name]
                        : null;
                    return row;
                });
            }
            promises.push(promise);
        }
        for (const key in input) {
            let field = this.model.field(key);
            if (field instanceof sqlex_1.ForeignKeyField &&
                input[key] &&
                typeof input[key] === 'object') {
                _createPromise(field, input[key]);
            }
            else if (field instanceof sqlex_1.SimpleField) {
                result[key] = input[key];
            }
        }
        return Promise.all(promises).then(() => result);
    }
    _create(connection, data) {
        if (Object.keys(data).length === 0)
            throw Error('Empty data');
        return this._resolveParentFields(connection, data).then(row => this._insert(connection, row).then(id => {
            return this._updateChildFields(connection, data, id).then(() => this._get(connection, id).then(row => this.closureTable
                ? tree_1.createNode(connection, this, row).then(() => row)
                : row));
        }));
    }
    _upsert(connection, data, update) {
        if (!this.model.checkUniqueKey(data)) {
            return Promise.reject(`Incomplete: ${JSON.stringify(data)}`);
        }
        const self = this;
        return this._resolveParentFields(connection, data).then(row => {
            const uniqueFields = getUniqueFields(self.model, row);
            return self._get(connection, uniqueFields).then(row => {
                if (!row) {
                    return self._create(connection, data);
                }
                else {
                    if (update && Object.keys(update).length > 0) {
                        return self._modify(connection, update, uniqueFields);
                    }
                    else {
                        return row;
                    }
                }
            });
        });
    }
    _modify(connection, data, filter) {
        if (!this.model.checkUniqueKey(filter)) {
            return Promise.reject(`Bad filter: ${JSON.stringify(filter)}`);
        }
        const self = this;
        return this._resolveParentFields(connection, data, filter).then(row => {
            return self._update(connection, row, filter).then(() => {
                const where = Object.assign({}, filter);
                for (const key in where) {
                    if (key in row) {
                        where[key] = row[key];
                    }
                }
                return self._get(connection, where).then(row => {
                    if (row) {
                        const id = row[this.model.keyField().name];
                        return this._updateChildFields(connection, data, id).then(() => !this.closureTable || !data[this.getParentField().name]
                            ? row
                            : tree_1.moveSubtree(connection, this, row).then(() => row));
                    }
                    else {
                        return Promise.resolve(row);
                    }
                });
            });
        });
    }
    _updateChildFields(connection, data, id) {
        const promises = [];
        for (const key in data) {
            let field = this.model.field(key);
            if (field instanceof sqlex_1.RelatedField) {
                promises.push(this._updateChildField(connection, field, id, data[key]));
            }
        }
        return Promise.all(promises);
    }
    _updateChildField(connection, related, id, data) {
        const promises = [];
        const field = related.referencingField;
        if (!field)
            throw Error(`Bad field ${related.fullname}`);
        const table = this.db.table(field.model);
        if (!data || field.model.keyValue(data) === null) {
            if (field.column.nullable) {
                return table._update(connection, { [field.name]: null }, { [field.name]: id });
            }
            else {
                return table._delete(connection, { [field.name]: id });
            }
        }
        for (const method in data) {
            const args = data[method];
            if (method === 'connect') {
                if (related.throughField) {
                    promises.push(this._connectThrough(connection, related, id, args));
                    continue;
                }
                // connect: [{parent: {id: 2}, name: 'Apple'}, ...]
                for (const arg of misc_1.toArray(args)) {
                    if (!table.model.checkUniqueKey(arg)) {
                        return Promise.reject(`Bad filter (${table.model.name})`);
                    }
                    let promise;
                    if (field.isUnique()) {
                        promise = this._disconnectUnique(connection, field, id).then(() => table._update(connection, { [field.name]: id }, args));
                    }
                    else {
                        promise = table._update(connection, { [field.name]: id }, args);
                    }
                    promises.push(promise);
                }
            }
            else if (method === 'create') {
                if (related.throughField) {
                    promises.push(this._createThrough(connection, related, id, args));
                    continue;
                }
                // create: [{parent: {id: 2}, name: 'Apple'}, ...]
                const docs = misc_1.toArray(args).map(arg => (Object.assign({ [field.name]: id }, arg)));
                if (field.isUnique()) {
                    promises.push(this._disconnectUnique(connection, field, id).then(() => table._create(connection, docs[0])));
                }
                else {
                    for (const doc of docs) {
                        promises.push(table._create(connection, doc));
                    }
                }
            }
            else if (method === 'upsert') {
                if (related.throughField) {
                    promises.push(this._upsertThrough(connection, related, id, args));
                    continue;
                }
                for (const arg of misc_1.toArray(args)) {
                    let { create, update } = arg;
                    if (!create && !field.isUnique()) {
                        throw Error('Bad data');
                    }
                    create = Object.assign({ [field.name]: id }, create);
                    if (create[field.name] === undefined) {
                        update = Object.assign({ [field.name]: id }, update);
                    }
                    promises.push(table._upsert(connection, create, update));
                }
            }
            else if (method === 'update') {
                if (related.throughField) {
                    promises.push(this._updateThrough(connection, related, id, args));
                    continue;
                }
                for (const arg of misc_1.toArray(args)) {
                    let data, where;
                    if (arg.data === undefined) {
                        data = arg;
                        where = {};
                    }
                    else {
                        data = arg.data;
                        where = arg.where;
                    }
                    const filter = Object.assign({ [field.name]: id }, where);
                    promises.push(table._modify(connection, data, filter));
                }
            }
            else if (method === 'delete') {
                if (related.throughField) {
                    promises.push(this._deleteThrough(connection, related, id, args));
                    continue;
                }
                const filter = args.map(arg => (Object.assign(Object.assign({}, arg /*.where*/), { [field.name]: id })));
                promises.push(table._delete(connection, filter));
            }
            else if (method === 'disconnect') {
                if (related.throughField) {
                    promises.push(this._disconnectThrough(connection, related, id, args));
                    continue;
                }
                const where = args.map(arg => (Object.assign({ [field.name]: id }, arg)));
                promises.push(table._update(connection, { [field.name]: null }, where));
            }
            else if (method === 'set') {
                let promise = related.throughField
                    ? this._deleteThrough(connection, related, id, [])
                    : table._delete(connection, { [field.name]: id });
                promise = promise.then(() => {
                    if (related.throughField) {
                        return this._createThrough(connection, related, id, args);
                    }
                    // create: [{parent: {id: 2}, name: 'Apple'}, ...]
                    const docs = misc_1.toArray(args).map(arg => (Object.assign({ [field.name]: id }, arg)));
                    if (field.isUnique()) {
                        return this._disconnectUnique(connection, field, id).then(() => table._create(connection, docs[0]));
                    }
                    else {
                        return Promise.all(docs.map(doc => table._create(connection, doc)));
                    }
                });
                promises.push(promise);
            }
            else {
                throw Error(`Unknown method: ${method}`);
            }
        }
        return Promise.all(promises);
    }
    _disconnectUnique(connection, field, id) {
        const table = this.db.table(field.model);
        return field.column.nullable
            ? table._update(connection, { [field.name]: null }, { [field.name]: id })
            : table._delete(connection, { [field.name]: id });
    }
    _connectThrough(connection, related, value, args) {
        const table = this.db.table(related.throughField.referencedField.model);
        const mapping = this.db.table(related.throughField.model);
        const promises = args.map(arg => table._get(connection, arg).then(row => row
            ? mapping._create(connection, {
                [related.referencingField.name]: value,
                [related.throughField.name]: row[table.model.keyField().name]
            })
            : Promise.resolve(null)));
        return Promise.all(promises);
    }
    _createThrough(connection, related, value, args) {
        const table = this.db.table(related.throughField.referencedField.model);
        const mapping = this.db.table(related.throughField.model);
        const promises = args.map(arg => table._create(connection, arg).then(row => mapping._create(connection, {
            [related.referencingField.name]: value,
            [related.throughField.name]: row[table.model.keyField().name]
        })));
        return Promise.all(promises);
    }
    _upsertThrough(connection, related, value, args) {
        const table = this.db.table(related.throughField.referencedField.model);
        const mapping = this.db.table(related.throughField.model);
        const promises = args.map(arg => table
            ._upsert(connection, arg.create, arg.update)
            .then(row => mapping._upsert(connection, {
            [related.referencingField.name]: value,
            [related.throughField.name]: row[table.model.keyField().name]
        })));
        return Promise.all(promises);
    }
    _updateThrough(connection, related, value, args) {
        const model = related.throughField.referencedField.model;
        const promises = args.map(arg => {
            let where;
            if (related.throughField.relatedField.throughField) {
                where = Object.assign({ [related.throughField.relatedField.name]: {
                        [related.model.keyField().name]: value
                    } }, arg.where);
            }
            else {
                where = Object.assign({ [related.throughField.relatedField.name]: {
                        [related.referencingField.name]: value
                    } }, arg.where);
            }
            return this.db
                .table(model)
                ._modify(connection, arg.data, where);
        });
        return Promise.all(promises);
    }
    _deleteThrough(connection, related, value, args) {
        const mapping = this.db.table(related.throughField.model);
        const table = this.db.table(related.throughField.referencedField.model);
        return mapping
            ._select(connection, '*', {
            where: {
                [related.referencingField.name]: value,
                [related.throughField.name]: args
            }
        })
            .then(rows => {
            if (rows.length === 0)
                return Promise.resolve(0);
            const values = rows.map(row => row[related.throughField.name][table.model.keyField().name]);
            return mapping._delete(connection, rows).then(() => table._delete(connection, {
                [table.model.keyField().name]: values
            }));
        });
    }
    _disconnectThrough(connection, related, value, args) {
        const mapping = this.db.table(related.throughField.model);
        return mapping._delete(connection, {
            [related.referencingField.name]: value,
            [related.throughField.name]: args
        });
    }
    claim(filter, data, orderBy) {
        const self = this;
        const MAX_TRY = 5;
        let try_count = 0;
        return new Promise(resolve => {
            function _select() {
                self.select('*', { where: filter, limit: 10, orderBy }).then(rows => {
                    if (rows.length === 0) {
                        resolve(null);
                    }
                    else {
                        const row = rows[Math.floor(Math.random() * rows.length)];
                        _update(row);
                    }
                });
            }
            function _update(row) {
                const where = Object.assign(Object.assign({}, filter), getUniqueFields(self.model, row));
                self
                    .update(data, where)
                    .then(result => {
                    if (result.changedRows === 1) {
                        resolve(row);
                    }
                    else if (try_count++ < MAX_TRY) {
                        setTimeout(_select, Math.random() * 1000);
                    }
                    else {
                        throw Error('Too busy');
                    }
                })
                    .catch(error => {
                    // Error: SQLITE_BUSY: database is locked
                    if (try_count++ < MAX_TRY) {
                        setTimeout(_select, Math.random() * 1000);
                    }
                    else {
                        throw error;
                    }
                });
            }
            _select();
        });
    }
    append(data) {
        const record = new Proxy(new record_1.Record(this), record_1.RecordProxy);
        Object.assign(record, data);
        const existing = this._mapGet(record);
        if (!existing) {
            this.recordList.push(record);
            this._mapPut(record);
            return record;
        }
        for (const name in data) {
            if (existing[name] != data[name]) {
                const field = record.__table.model.field(name);
                if (field instanceof sqlex_1.ForeignKeyField) {
                    const model = field.referencedField.model;
                    if (existing[name] !== undefined) {
                        if (pkOf(model, existing[name]) == pkOf(model, data[name])) {
                            continue;
                        }
                    }
                }
                existing[name] = data[name];
            }
        }
        return existing;
    }
    clear() {
        this.recordList = [];
        this._initMap();
    }
    getDirtyCount() {
        let dirtyCount = 0;
        for (const record of this.recordList) {
            if (record.__dirty() && !record.__state.merged) {
                dirtyCount++;
            }
        }
        return dirtyCount;
    }
    json() {
        return this.recordList.map(record => record.__json());
    }
    _mapGet(record) {
        let existing;
        for (const uc of this.model.uniqueKeys) {
            const value = record.__valueOf(uc);
            if (value !== undefined) {
                const record = this.recordMap[uc.name()][value];
                if (record) {
                    if (existing && existing !== record) {
                        throw Error(`Inconsistent unique constraint values`);
                    }
                    existing = record;
                }
            }
        }
        return existing;
    }
    _mapPut(record) {
        for (const uc of this.model.uniqueKeys) {
            const value = record.__valueOf(uc);
            if (value !== undefined) {
                this.recordMap[uc.name()][value] = record;
            }
        }
    }
    _initMap() {
        this.recordMap = this.model.uniqueKeys.reduce((map, uc) => {
            map[uc.name()] = {};
            return map;
        }, {});
    }
    _selectRelated(connection, field, values, fields, selectOptions) {
        const table = this.db.table(field.referencingField.model);
        const name = field.referencingField.name;
        if (selectOptions.limit) {
            const promises = [];
            if (field.throughField) {
                for (const value of values) {
                    const options = Object.assign({}, selectOptions);
                    options.where = {
                        [field.throughField.name]: options.where,
                        [field.referencingField.name]: value
                    };
                    if (options.orderBy) {
                        const prefix = field.throughField.name;
                        options.orderBy = misc_1.toArray(options.orderBy).map((name) => name[0] === '-'
                            ? `-${prefix}.${name.substring(1)}`
                            : `${prefix}.${name}`);
                    }
                    promises.push(table
                        .select({ [field.throughField.name]: fields }, options, undefined, connection)
                        .then(rows => rows.map(row => row[field.throughField.name])));
                }
            }
            else {
                for (const value of values) {
                    const options = Object.assign({}, selectOptions);
                    options.where = Object.assign({}, options.where, { [name]: value });
                    promises.push(table.select(fields, options, undefined, connection).then(rows => {
                        if (field.referencingField.isUnique()) {
                            const row = rows[0];
                            if (row) {
                                delete row[name];
                            }
                            return row;
                        }
                        else {
                            return rows.map(row => {
                                delete row[name];
                                return row;
                            });
                        }
                    }));
                }
            }
            return Promise.all(promises);
        }
        const options = Object.assign({ where: {} }, selectOptions);
        if (field.throughField) {
            options.where = { [field.throughField.name]: options.where };
            options.where[field.referencingField.name] = values;
            if (options.orderBy) {
                const prefix = field.throughField.name;
                options.orderBy = misc_1.toArray(options.orderBy).map((name) => name[0] === '-'
                    ? `-${prefix}.${name.substring(1)}`
                    : `${prefix}.${name}`);
            }
            return table
                .select({ [field.throughField.name]: fields }, options, undefined, connection)
                .then(rows => {
                const id = field.referencingField.model.keyField().name;
                if (field.referencingField.isUnique()) {
                    return values.map(key => {
                        const row = rows.find(row => row[name][id] === key);
                        return row ? row[field.throughField.name] : undefined;
                    });
                }
                else {
                    return values
                        .map(key => rows.filter(row => row[name][id] === key))
                        .map(docs => docs.map(doc => doc[field.throughField.name]));
                }
            });
        }
        else {
            options.where[name] = values;
            return table.select(fields, options, undefined, connection).then(rows => {
                const id = field.referencingField.model.keyField().name;
                if (field.referencingField.isUnique()) {
                    return values.map(key => {
                        const row = rows.find(row => row[name] && row[name][id] === key);
                        if (row) {
                            delete row[name];
                        }
                        return row;
                    });
                }
                else {
                    return values
                        .map(key => rows.filter(row => row[name][id] === key))
                        .map(docs => {
                        for (const doc of docs) {
                            delete doc[name];
                        }
                        return docs;
                    });
                }
            });
        }
    }
    // It is strongly recommended to call db.clear() before calling this method!
    xappend(data, config, defaults) {
        return loader_1.loadTable(this, data, config, defaults);
    }
    xselect(config, options = {}) {
        config = Object.assign({}, config);
        let attrs;
        if (config['*']) {
            attrs = config['*'];
            delete config['*'];
        }
        const fields = loader_1.recordConfigToDocument(this, config);
        return this.select(fields, options).then(docs => {
            if (attrs) {
                const options = loader_1.parseRelatedOption(attrs);
                const table = this.db.table(this.model.field(options.name).referencingField
                    .model);
                const range = docs.map(doc => this.model.keyValue(doc));
                const field = table.model.getForeignKeyOf(this.model);
                return table
                    .select('*', { where: { [field.name]: range } })
                    .then(rows => {
                    const result = [];
                    for (const doc of docs) {
                        const kv = this.model.keyValue(doc);
                        const rs = rows.filter(row => this.model.keyValue(row[field.name]) === kv);
                        for (const d of loader_1.mapDocument(doc, config)) {
                            for (const r of rs) {
                                const name = r[options.key];
                                const value = r[options.value];
                                d[name] = value;
                            }
                            result.push(d);
                        }
                    }
                    return result;
                });
            }
            else {
                return [].concat.apply([], docs.map(doc => loader_1.mapDocument(doc, config)));
            }
        });
    }
    selectTree(filter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = yield (options
                ? select_1.selectTree(this, filter, options)
                : select_1.selectTree2(this, filter));
            const serialiser = new serialiser_1.JsonSerialiser(data);
            return serialiser.serialise(this.model);
        });
    }
}
exports.Table = Table;
function _toCamel(value, field) {
    if (value === null || value === undefined)
        return null;
    if (value instanceof record_1.Record)
        return value;
    if (/text|string/i.test(field.column.type)) {
        return value;
    }
    if (/date|time/i.test(field.column.type)) {
        // MUST BE IN ISO 8601 FORMAT!
        return new Date(value).toISOString();
    }
    if (/int|long/i.test(field.column.type)) {
        return typeof value === 'boolean'
            ? value
                ? 1
                : 0
            : parseInt(value);
    }
    if (/float|double/i.test(field.column.type)) {
        return parseFloat(value);
    }
    if (/^bool/i.test(field.column.type)) {
        if (typeof value === 'boolean') {
            return value;
        }
        if (typeof value === 'string') {
            return /^false|0$/i.test(value) ? false : true;
        }
        return !!value;
    }
    if (field.uniqueKey) {
        // mysql ...
        return (value + '').trim();
    }
    return value;
}
exports._toCamel = _toCamel;
function toRow(value, field) {
    if (value && /date|time/i.test(field.column.type)) {
        return new Date(value)
            .toISOString()
            .slice(0, 23) // datetime(3)
            .replace('T', ' ');
    }
    return value;
}
exports.toRow = toRow;
function setNullForeignKeys(result, model) {
    if (model.keyValue(result) === null) {
        return null;
    }
    for (const field of model.fields) {
        if (field instanceof sqlex_1.ForeignKeyField && result[field.name]) {
            result[field.name] = setNullForeignKeys(result[field.name], field.referencedField.model);
        }
    }
    return result;
}
function toDocument(row, model, fieldMap = {}) {
    const result = {};
    for (const key in row) {
        const fieldNames = key.split('__');
        let currentResult = result;
        let currentModel = model;
        for (let i = 0; i < fieldNames.length - 1; i++) {
            const fieldName = fieldNames[i];
            if (!currentResult[fieldName]) {
                currentResult[fieldName] = {};
            }
            const field = currentModel.field(fieldName);
            if (!(field instanceof sqlex_1.ForeignKeyField)) {
                throw Error(`Not a foreign key: ${key}`);
            }
            currentResult = currentResult[fieldName];
            currentModel = field.referencedField.model;
        }
        const field = currentModel.field(fieldNames[fieldNames.length - 1]);
        const fieldName = fieldMap[key] || field.name;
        if (field instanceof sqlex_1.SimpleField) {
            const value = _toCamel(row[key], field);
            if (field instanceof sqlex_1.ForeignKeyField) {
                if (value !== null) {
                    if (!(field.name in currentResult)) {
                        currentResult[fieldName] = {};
                    }
                    let keyField = field.referencedField.model.keyField();
                    let result = currentResult[fieldName];
                    while (keyField instanceof sqlex_1.ForeignKeyField) {
                        result[keyField.name] = {};
                        result = result[keyField.name];
                        keyField = keyField.referencedField.model.keyField();
                    }
                    result[keyField.name] = value;
                }
                else {
                    currentResult[fieldName] = null;
                }
            }
            else {
                currentResult[fieldName] = value;
            }
        }
    }
    return setNullForeignKeys(result, model);
}
exports.toDocument = toDocument;
function isEmpty(value) {
    if (value === undefined) {
        return true;
    }
    if (value instanceof record_1.Record) {
        while (value.__state.merged) {
            value = value.__state.merged;
        }
        if (value.__primaryKeyDirty())
            return true;
        return isEmpty(value.__primaryKey());
    }
    return false;
}
exports.isEmpty = isEmpty;
function pkOf(model, data) {
    if (sqlex_1.isValue(data))
        return data;
    const pk = model.keyField();
    if (pk instanceof sqlex_1.ForeignKeyField) {
        return pkOf(pk.referencedField.model, data[pk.name]);
    }
    return data[pk.name];
}
function shouldSelectSeparately(model, fields) {
    if (typeof fields === 'string') {
        return false;
    }
    for (const name in fields) {
        if (model.field(name) instanceof sqlex_1.RelatedField) {
            return true;
        }
    }
    return false;
}
exports.shouldSelectSeparately = shouldSelectSeparately;
function getUniqueFields(model, row) {
    const uniqueKey = model.checkUniqueKey(row);
    if (uniqueKey) {
        const fields = {};
        for (const field of uniqueKey.fields) {
            const value = row[field.name];
            if (value instanceof record_1.Record) {
                fields[field.name] = value.__primaryKey();
            }
            else {
                fields[field.name] = row[field.name];
            }
        }
        return fields;
    }
}
exports.getUniqueFields = getUniqueFields;
//# sourceMappingURL=database.js.map