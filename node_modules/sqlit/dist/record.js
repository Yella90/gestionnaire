"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getModel = exports.RecordSet = exports.Record = exports.RecordProxy = void 0;
const database_1 = require("./database");
const sqlex_1 = require("sqlex");
const flush_1 = require("./flush");
const copy_1 = require("./copy");
exports.RecordProxy = {
    set: function (record, name, value) {
        if (!/^__/.test(name)) {
            if (value === undefined) {
                throw Error(`Assigning undefined to ${name}`);
            }
            const model = record.__table.model;
            const field = model.field(name);
            if (field instanceof sqlex_1.ForeignKeyField) {
                let lhs;
                if (record.__data[name] instanceof Record) {
                    const rec = record.__data[name];
                    lhs = rec.__getValue(field.name);
                }
                else {
                    lhs = record.__data[name];
                }
                const rhs = sqlex_1.isValue(value) ? value : model.valueOf(value, field);
                if (lhs !== undefined && lhs != rhs) {
                    const key = `${record.__table.name}.${name}`;
                    throw Error(`Reassigning ${key}: ${lhs} (new: ${rhs})`);
                }
                else {
                    if (value instanceof Record || value === null) {
                        record.__data[name] = value;
                    }
                    else {
                        const model = field.referencedField.model;
                        let removeDirty = false;
                        if (typeof value !== 'object') {
                            value = { [model.keyField().name]: value };
                            removeDirty = true;
                        }
                        const parent = record.__table.db.table(model).append(value);
                        record.__data[name] = parent;
                        if (removeDirty) {
                            parent.__remove_dirty(model.keyField().name);
                        }
                    }
                    record.__state.dirty.add(name);
                }
            }
            else if (field instanceof sqlex_1.SimpleField) {
                // user.email = 'user@example.com'
                record.__data[name] = database_1._toCamel(value, field);
                record.__state.dirty.add(name);
            }
            else if (field instanceof sqlex_1.RelatedField) {
                // Used by replace and __json() only
                record.__data[name] = value;
            }
            else {
                throw Error(`Invalid field: ${model.name}.${name}`);
            }
        }
        else {
            record[name] = value;
        }
        return true;
    },
    get: function (record, name) {
        if (typeof name === 'string' && !/^__/.test(name)) {
            if (typeof record[name] !== 'function') {
                const model = record.__table.model;
                const field = model.field(name);
                if (field instanceof sqlex_1.SimpleField) {
                    return record.__data[name];
                }
                else if (field instanceof sqlex_1.RelatedField) {
                    let recordSet = record.__related[name];
                    if (!recordSet) {
                        recordSet = new RecordSet(record, field);
                        record.__related[name] = recordSet;
                    }
                    return recordSet;
                }
            }
        }
        return record[name];
    }
};
class Record {
    constructor(table) {
        this.__table = table;
        this.__data = {};
        this.__state = new flush_1.FlushState();
        this.__related = {};
        this.__inserted = false;
        return new Proxy(this, exports.RecordProxy);
    }
    get(name) {
        return this.__data[name];
    }
    save() {
        if (!this.__dirty()) {
            return Promise.resolve(this);
        }
        return this.__table.db.pool.getConnection().then(connection => {
            return new Promise(resolve => {
                connection.transaction(() => {
                    flush_1.flushRecord(connection, this).then(result => {
                        connection.commit().then(() => {
                            connection.release();
                            resolve(result);
                        });
                    });
                });
            });
        });
    }
    update(data = {}) {
        for (const key in data) {
            this[key] = data[key];
        }
        this.__state.method = flush_1.FlushMethod.UPDATE;
        return this.save();
    }
    delete() {
        const filter = database_1.getUniqueFields(this.__table.model, this.__data);
        return this.__table.delete(filter);
    }
    copy(data, options) {
        return copy_1.copyRecord(this, data, options);
    }
    __dirty() {
        return this.__state.dirty.size > 0;
    }
    __flushable(perfect) {
        if (perfect < 0)
            return true;
        if (this.__state.merged) {
            return false;
        }
        const data = this.__data;
        if (!this.__table.model.checkUniqueKey(data, database_1.isEmpty)) {
            if (this.__table.model.uniqueKeys.length > 1 ||
                !this.__table.model.primaryKey.autoIncrement()) {
                return false;
            }
        }
        else if (this.__state.method === flush_1.FlushMethod.DELETE) {
            return true;
        }
        let flushable = 0;
        this.__state.dirty.forEach(key => {
            if (!database_1.isEmpty(data[key])) {
                flushable++;
            }
        });
        if (flushable === 0)
            return false;
        return perfect ? flushable === this.__state.dirty.size : true;
    }
    __fields() {
        const fields = {};
        this.__state.dirty.forEach(key => {
            if (!database_1.isEmpty(this.__data[key])) {
                fields[key] = this.__getValue(key);
            }
        });
        return fields;
    }
    __remove_dirty(keys) {
        if (typeof keys === 'string') {
            this.__state.dirty.delete(keys);
        }
        else {
            for (const key of keys) {
                this.__state.dirty.delete(key);
            }
        }
    }
    __is_inserted() {
        if (this.__state.merged) {
            return this.__state.merged.__is_inserted();
        }
        return this.__inserted;
    }
    __getValue(name) {
        if (this.__data[name] instanceof Record) {
            let parent = this.__data[name];
            while (parent.__state.merged) {
                parent = parent.__state.merged;
            }
            return parent.__primaryKey();
        }
        return this.__data[name];
    }
    __primaryKey() {
        const name = this.__table.model.primaryKey.fields[0].name;
        const value = this.__data[name];
        if (value instanceof Record) {
            return value.__primaryKey();
        }
        return value;
    }
    __primaryKeyDirty() {
        const name = this.__table.model.primaryKey.fields[0].name;
        return this.__state.dirty.has(name);
    }
    __setPrimaryKey(value) {
        const name = this.__table.model.primaryKey.fields[0].name;
        this.__data[name] = value;
    }
    __filter() {
        const self = this;
        const data = Object.keys(this.__data).reduce(function (acc, cur, i) {
            acc[cur] = self.__getValue(cur);
            return acc;
        }, {});
        return database_1.getUniqueFields(this.__table.model, data);
    }
    __valueOf(uc) {
        const values = [];
        for (const field of uc.fields) {
            let value = this.__getValue(field.name);
            if (value === undefined)
                return undefined;
            values.push(database_1._toCamel(value, field) + '');
        }
        return JSON.stringify(values).toLocaleLowerCase();
    }
    __merge() {
        let root = this.__state.merged;
        while (root.__state.merged) {
            root = root.__state.merged;
        }
        const self = this;
        this.__state.dirty.forEach(name => {
            root.__data[name] = self.__data[name];
            root.__state.dirty.add(name);
        });
    }
    __updateState(existing) {
        if (!this.__primaryKey()) {
            this.__setPrimaryKey(existing.__primaryKey());
        }
        for (const name in existing.__data) {
            if (!this.__state.dirty.has(name))
                continue;
            const lhs = this.__getValue(name);
            const rhs = existing.__getValue(name);
            // TODO: type wise
            if (lhs == rhs) {
                this.__state.dirty.delete(name);
            }
        }
        if (this.__dirty()) {
            if (this.__state.method === flush_1.FlushMethod.INSERT) {
                this.__state.method = flush_1.FlushMethod.UPDATE;
            }
        }
        this.__state.selected = true;
    }
    __json() {
        const result = {};
        for (const field of this.__table.model.fields) {
            const value = this.__getValue(field.name);
            if (Array.isArray(value)) {
                result[field.name] = value.map(record => record.__json());
                for (const item of result[field.name]) {
                    delete item[field.referencingField.name];
                }
            }
            else if (value !== undefined) {
                result[field.name] = value;
            }
        }
        return result;
    }
    __dump() {
        const data = { __state: this.__state.json() };
        for (const field of this.__table.model.fields) {
            let name = field.name;
            const value = this.__data[name];
            if (value !== undefined) {
                if (this.__state.merged) {
                    name = '!' + name;
                }
                else if (this.__state.dirty.has(name)) {
                    name = '*' + name;
                }
                if (sqlex_1.isValue(value)) {
                    data[name] = value;
                }
                else {
                    const record = value;
                    data[name] = record.__repr();
                }
            }
        }
        return data;
    }
    __repr() {
        const model = this.__table.model;
        const value = this.__data[model.keyField().name];
        if (value === undefined || sqlex_1.isValue(value)) {
            return `${model.name}(${value})`;
        }
        else {
            const record = value;
            return `${model.name}(${record.__repr()})`;
        }
    }
}
exports.Record = Record;
class RecordSet {
    constructor(record, field) {
        this.record = record;
        this.field = field;
    }
    // user.groups.add(admin)
    add(record) {
        const data = { [this.field.name]: { upsert: { create: record.__data } } };
        const filter = this.record.__filter();
        return this.record.__table.modify(data, filter);
    }
    // user.groups.replaceWith([admin, customer])
    replaceWith() { }
    // user.groups.remove(admin)
    remove(record) {
        const data = { [this.field.name]: { delete: [record.__filter()] } };
        const filter = this.record.__filter();
        return this.record.__table.modify(data, filter);
    }
}
exports.RecordSet = RecordSet;
function getModel(table, bulk = false) {
    const model = function (data) {
        if (bulk)
            return table.append(data);
        const record = new Proxy(new Record(table), exports.RecordProxy);
        Object.assign(record, data);
        return record;
    };
    model.table = table;
    model.fields = table.model.fields;
    return model;
}
exports.getModel = getModel;
//# sourceMappingURL=record.js.map