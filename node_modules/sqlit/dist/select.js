"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.selectTree2 = exports.selectTree = void 0;
const sqlex_1 = require("sqlex");
function selectTree(table, filter, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = {};
        const querySet = new Set();
        return _selectTree(table, filter, options, result, null, querySet);
    });
}
exports.selectTree = selectTree;
function _selectTree(table, filter, options = {}, result = {}, entry, querySet) {
    return __awaiter(this, void 0, void 0, function* () {
        const rows = yield table.select('*', { where: filter });
        if (rows.length === 0)
            return result;
        const map = merge(result, table, rows);
        const model = table.model;
        const db = table.db;
        for (const field of table.model.fields) {
            if (field instanceof sqlex_1.ForeignKeyField) {
                let option;
                if (typeof options === 'string') {
                    if (options !== '**')
                        continue;
                    option = '**';
                }
                else {
                    option = options[field.name];
                }
                if (!option)
                    continue;
                const table = db.table(field.referencedField);
                const map = merge(result, table);
                const values = rows
                    .map(r => model.valueOf(r, field))
                    .filter(value => !map.has(value));
                if (values.length > 0) {
                    if (mayQuery(querySet, [table.model.keyField()], values)) {
                        const filter = { [table.model.keyField().name]: values };
                        yield _selectTree(table, filter, option, result, field, querySet);
                    }
                }
            }
        }
        const values = [...map.keys()];
        for (const table of db.tableList) {
            const fields = [];
            const fieldsThrough = [];
            for (const field of table.model.fields) {
                if (!(field instanceof sqlex_1.ForeignKeyField))
                    continue;
                if (!(field.referencedField.model === model))
                    continue;
                if (!field.relatedField)
                    continue;
                if (field === entry)
                    continue;
                const option = typeof options === 'string'
                    ? options
                    : options[field.relatedField.name];
                if (option === '')
                    continue;
                if (field.relatedField.throughField) {
                    fieldsThrough.push([field, option]);
                }
                else {
                    fields.push([field, option]);
                }
            }
            if (fieldsThrough.length > 0) {
                const filter = fieldsThrough.map(field => ({ [field[0].name]: values }));
                const rows = yield table.select('*', { where: filter });
                merge(result, table, rows);
                for (const [field, option] of fieldsThrough) {
                    const key = field.relatedField.throughField;
                    const table = db.table(key.referencedField);
                    const map = merge(result, table);
                    const values = rows
                        .map(r => table.model.valueOf(r, key))
                        .filter(value => !map.has(value));
                    if (values.length > 0) {
                        if (mayQuery(querySet, [table.model.keyField()], values)) {
                            const filter = { [table.model.keyField().name]: values };
                            yield _selectTree(table, filter, option, result, key, querySet);
                        }
                    }
                }
            }
            if (fields.length > 0) {
                if (mayQuery(querySet, fields.map(field => field[0]), values)) {
                    const filter = fields.map(field => ({ [field[0].name]: values }));
                    yield _selectTree(table, filter, fields[0][1], result, null, querySet);
                }
            }
        }
        return result;
    });
}
function merge(result, table, rows) {
    const model = table.model;
    let map = result[model.name];
    if (!map) {
        map = new Map();
        result[model.name] = map;
    }
    if (rows) {
        const key = model.keyField();
        for (const row of rows) {
            map.set(model.valueOf(row, key), row);
        }
    }
    return map;
}
function mayQuery(querySet, fields, values) {
    const key = fields
        .map(field => field.fullname + JSON.stringify(values))
        .join('/');
    if (!querySet.has(key)) {
        querySet.add(key);
        return true;
    }
    return false;
}
function selectTree2(table, filter) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = {};
        const rows = yield table.select('*', { where: filter });
        merge(result, table, rows);
        const selected = new Map([[table, 0]]);
        const db = table.db;
        while (true) {
            let min = Infinity;
            let next;
            for (const child of db.tableList) {
                if (selected.has(child))
                    continue;
                selected.forEach((distance, parent) => {
                    const keys = getForeignKeys(child, parent);
                    if (keys.length > 0 && distance < min) {
                        next = { parent, child, keys };
                        min = distance;
                    }
                });
            }
            if (!next)
                break;
            const values = [...result[next.parent.model.name].keys()];
            if (values.length > 0) {
                const filter = next.keys.map(key => ({
                    [key.name]: values
                }));
                const rows = yield next.child.select('*', { where: filter });
                merge(result, next.child, rows);
                if (next.keys.length === 1) {
                    const key = next.keys[0];
                    if (key.relatedField && key.relatedField.throughField) {
                        const model = next.child.model;
                        let values = rows.map(row => model.valueOf(row, key.relatedField.throughField));
                        const table = db.table(key.relatedField.throughField.referencedField);
                        const map = result[table.model.name];
                        if (map) {
                            values = values.filter(pk => !map.has(pk));
                        }
                        if (values.length > 0) {
                            const key = table.model.keyField().name;
                            const rows = yield table.select('*', { where: { [key]: values } });
                            merge(result, table, rows);
                            selected.set(table, min + 1);
                        }
                    }
                }
            }
            else {
                merge(result, next.child, []);
            }
            selected.set(next.child, min + 1);
        }
        return result;
    });
}
exports.selectTree2 = selectTree2;
function getForeignKeys(child, parent) {
    const result = [];
    for (const field of child.model.fields) {
        if (field instanceof sqlex_1.ForeignKeyField) {
            if (field.referencedField.model === parent.model) {
                result.push(field);
            }
        }
    }
    return result;
}
//# sourceMappingURL=select.js.map